import json
import re
import copy
import pprint
import collections

data = {
    'undefined' : {'_type' : 'undefined'}
}


#_type type_decl
#_string int
main = {
    '_string': 1,
    "_id": "77817",
#    "_type": "tree_list",
    'srcp' : '',
    'addr' : '', # many strings
    'val' : '', # many strings
    'value' :'',
    'valu' :''
}

scalars = {
    
    "algn": {"32": 2188, "8": 2990, "128": 17, "64": 5629, "16": 211, "1": 102},
    "prec": {"32": 250, "8": 26, "128": 7, "64": 218, "16": 41, "80": 1, "1": 1, "2": 1, "4": 1, "59": 1, "40": 1, "31": 1, "5": 1, "14": 1, "7": 1, "24": 1, "0": 1, "30": 1, "48": 1, "52": 1},
    "sign": {"signed": 209, "unsigned": 339},
    "tag": {"struct": 760, "union": 120},
    "link": {"extern": 4048, "static": 440},
    "qual": {"c ": 133, "v ": 14, "r ": 99, "cv ": 2},
    "used": {"1": 2194, "0": 66},
    "length": {"1": 176, "4": 5, "7": 11, "6": 12, "98": 1, "3": 53, "2": 126, "5": 29, "8": 1, "16": 2, "23": 1, "18": 1, "21": 1, "12": 1, "13": 1, "11": 1, "42": 1, "9": 1}
}

remove = {
    '_id' :1,

}

clean = set(scalars.keys()).union(set(main.keys())).union(set(remove.keys()))
#print(clean)


fields = {
    "name": "77813", "type": "77808",
    # "chain": "1382",
    #"_string": "__divtc3",
    "size": "127",
    
    #"algn": 128, "prec": 32, "sign": "unsigned",
    "min": "28", "max": "29",
    #"value": "1248",
    "unql": "100", "elts": "1215", "domn": "10839",
    #"tag": "union",
    "flds": "77349", "ptd": "76426",
    #"srcp": "<built-in>:0",
    "scpe": "154",
    "bpos": "1367",
    "mngl": "77769",
    "body": "undefined",
    # "link": "extern",
    "retn": "77811", "prms": "77812",
    #"valu": "75148",
#    "chan": "165",
    #"qual": "c ",
    "csts": "77230", "cnst": "1132", "purp": "77262", "args": "76066", "argt": "203",
    #"used": "1",
    "expr": "75501", "OP0 :": "76077", "OP1": "11725", "vars": "73454", "init": "73849",
          
    "E0": "76105", "E1": "1025", "E2": "76087", "OP2": "73303", "fn": "76104", "E3": "76097", "E4": "74695", "E5": "73030", "E6": "73031", "E7": "73032", "E8": "73033", "E9": "73034", "E10": "72687", "labl": "73304", "E11": "72084", "E12": "72085", "E13": "72086", "E14": "72087",
    #"addr": "sshd     ", "val": "sshd ",
    "decl": "73182", "cond": "70566",
    #"length": 2,
    "idx": "8400", "low": "9524",

    #"E15": "72088",
    "orig": "30807",
    #"E16": "72089", "E17": "72090", "E18": "72091", "E19": "72092", "E20": "72093", "E21": "72094", "E22": "72095", "E23": "72096", "E24": "72097", "E25": "72098", "E26": "72099", "E27": "72100", "E28": "72101", "E29": "72102", "E30": "72103", "E31": "72104", "E32": "72105", "E33": "72106", "E34": "72107", "E35": "72108", "E36": "72109", "E37": "72110", "E38": "72111", "E39": "72112", "E40": "72113", "E41": "72114", "E42": "72115", "E43": "72116", "E44": "72117", "E45": "72118", "E46": "72119", "E47": "72120", "E48": "72121", "E49": "72122", "E50": "72123", "E51": "72124", "E52": "72125", "E53": "72126", "E54": "72127", "E55": "72128", "E56": "72129", "E57": "72130", "E58": "72131", "E59": "72132", "E60": "72133", "E61": "72134", "E62": "72135", "E63": "72136", "E64": "72137", "E65": "72138", "E66": "72139", "E67": "72140", "E68": "72141", "E69": "72142", "E70": "72143", "E71": "72144", "E72": "72145", "E73": "72146", "E74": "72147", "E75": "72148", "E76": "72149", "E77": "72150", "E78": "72151", "E79": "72152", "E80": "72153", "E81": "72154", "E82": "72155", "E83": "72156", "E84": "72157", "E85": "72158", "E86": "72159", "E87": "72160", "E88": "72161", "E89": "72162", "E90": "72163", "E91": "72164", "E92": "72165", "E93": "72166", "E94": "72167", "E95": "72168", "E96": "72169", "E97": "72170", "E98": "49539", "E99": "49540", "E100": "49541", "E101": "49542", "E102": "49543", "E103": "49544", "E104": "49545", "E105": "49546", "E106": "49547", "E107": "49548", "E108": "49549", "E109": "49550", "E110": "49551", "E111": "49552", "E112": "49553", "E113": "49554", "E114": "49555", "E115": "49556", "E116": "49557", "E117": "49558", "E118": "49559", "E119": "49560", "E120": "49561", "E121": "49562", "E122": "49563", "E123": "49564", "E124": "49565", "E125": "49566", "E126": "49567", "E127": "49568", "E128": "49569", "E129": "49570", "E130": "49571", "E131": "49572", "E132": "49573", "E133": "49574", "E134": "49575", "E135": "49576", "E136": "49577", "E137": "49578", "E138": "49579", "E139": "49580", "E140": "49581", "E141": "49582", "E142": "49583", "E143": "49584", "E144": "49585", "E145": "49586", "E146": "49587", "E147": "49588", "E148": "49589", "E149": "49590", "E150": "49591", "E151": "49592", "E152": "49593", "E153": "49594", "E154": "49595", "E155": "49596", "E156": "49597", "E157": "49598", "E158": "49599", "E159": "49600", "E160": "49601", "E161": "49602", "E162": "49603", "E163": "49604", "E164": "49605", "E165": "49606", "E166": "49607", "E167": "49608", "E168": "49609", "E169": "49610", "E170": "49611", "E171": "49612", "E172": "49613", "E173": "49614", "E174": "49615", "E175": "49616", "E176": "49617", "E177": "49618", "E178": "49619", "E179": "49620", "E180": "49621", "E181": "49622", "E182": "49623", "E183": "49624", "E184": "49625", "E185": "49626", "E186": "49627", "E187": "49628", "E188": "49629", "E189": "49630", "E190": "49631", "E191": "49632", "E192": "49633", "E193": "49634", "E194": "49635", "E195": "49636", "E196": "49637", "E197": "49638", "E198": "49639", "E199": "49640", "E200": "49641", "E201": "49642", "E202": "49643", "E203": "49644", "E204": "49645", "E205": "49646", "E206": "49647", "E207": "49648", "E208": "49649", "E209": "49650", "E210": "49651", "E211": "49652", "E212": "49653", "E213": "49654", "E214": "49655", "E215": "49656", "E216": "49657", "E217": "49658", "E218": "49659", "E219": "49660", "E220": "49661", "E221": "49662", "E222": "49663", "E223": "49664", "E224": "49665", "E225": "49666", "E226": "49667", "E227": "49668", "E228": "49669", "E229": "49670", "E230": "49671", "E231": "49672", "E232": "49673", "E233": "49674", "E234": "49675", "E235": "49676", "E236": "49677", "E237": "49678", "E238": "49679", "E239": "49680", "E240": "49681", "E241": "49682", "E242": "49683", "E243": "49684", "E244": "49685", "E245": "49686", "E246": "49687", "E247": "49688", "E248": "49689", "E249": "49690", "E250": "49691", "E251": "49692", "E252": "49693", "E253": "49694", "E254": "49695", "E255": "49696", "E256": "49697", "E257": "49698", "E258": "49699", "E259": "49700", "E260": "49701", "E261": "49702", "E262": "49703", "E263": "49704", "E264": "49432", "E265": "49433", "E266": "49434", "E267": "49435", "E268": "49436", "E269": "49437",
          "refd": "139"}

for x in clean :
    if x in fields:
        print("del",x)
        del fields[x]
def collect_scalars(d):
    for f in d:
        v = d[f]
        if f in main:
            continue
        if f not in fields:
            if f not in scalars:
                scalars[f] = { v : 1 }
            else:
                if v not in scalars[f] :
                    scalars[f][v]=1
                else:
                    scalars[f][v]=scalars[f][v]+1

# collect the data and the scalars
with open('t') as inf:
    for l in inf:
        d = json.loads(l)
        data[d['_id']]= d

positions = [
    'SELF' # 0 
    'PARENT', # 1
    'GRANDPARENT', # 2
    'GREAT-GRANDPARENT', # 3

]

def recurse_clean(dat,seen):
    for x in dat :
        v = dat[x]
        if "DUP" in v :
            if "FORWARD" in v["DUP"] :
                _id = v["DUP"]["FORWARD"]
                v2 = seen[_id]
                #print(v2)
                dat[x]= v2
                
        elif "FORWARD" in v:
            _id = v["FORWARD"]
            v2= seen[_id]
            #print(v2)
            dat[x]= v2
        else:
            if isinstance(v,dict):
                dat[x] = recurse_clean(v, seen)
                
    return dat

def recurse(_id, depth=0, seen = {}, root = None):
    if root == None:
        root = []
    else:
        if _id in root:
            idx = root.index(_id)
            pos = len(root)-1 - idx
            if pos < len( positions) :
                pos = positions[pos]
            elif idx == 0:
                pos = "ROOT"
            else:
                pos = "GREAT({})-GRANDPARENT".format(pos-3)                
            return "{}".format(pos)
        
    if depth > 900:
        return "STACK"
    
    if _id in seen:        
        return seen[_id]
    seen[_id] = {"FORWARD" : _id }
    d = data[_id]
    newt = {
        '_type' : d['_type'],
        #'_id' : _id,
    }
    
    #if "_string" in d:
    #    newt["_string"] = d["_string"]
        
    for f in d:
        v = d[f]
        if f in fields:
            newroot = []
            newroot.extend(root)
            newroot.append(_id)
            ft = recurse(_id=v, depth = depth + 1, seen=seen, root=newroot)
            newt[f]= ft
            seen[f] = ft
            
        #else:
            #seen[f] = "SKIP{}".format(v)
            # now replace all the fowards?
    # iterate and replace all forwards now
    
    newt = recurse_clean(newt,seen)
    seen[_id] = newt
    return newt
    
types2 = collections.Counter()

# now look at the fields
for _id in data:
    t = recurse(_id,depth=0, seen={})
    #print(_id, pprint.pformat(t))
    #print(t)

    types2[str(t)] += 1
        
for x in types2.most_common(10):
    print(x)

#print(json.dumps(data))
#for x in types2:
#    print(x, types2[x])

